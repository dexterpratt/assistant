# this module provides and interface to the neo4j
# database as a knowledge base, providing a set of
# higher level operators. 
#
# system node types
# These are reserved types, the agent cannot 
# invent new system node types.
# all system node types have names of the form "_name"
#
# _event. These are generated by user inputs.
# The record the input and the resulting actions taken 
# by the agent, including the final output
# response to the user.
#  
# recent _events are included in the short term 
# memory of the agent, i.e. the prompt text.
#
# _entity. These are neo4j nodes which
# represent instances, some of which are
# of the reserved type _class (classes),   
# of things about which the agent holds beliefs.
#
# Beliefs are edges between _entity nodes or
# properties of _entity nodes
#
# The agent can create _entity nodes (including classes)
# but it must check whether
# they are already represented in the system.
# all _entity nodes have names.
# all names must be unique in the system.
# 
# _relationship_type These are nodes that
# define the types of neo4j relationships 
# (edges) that the agent can
# assert between _entity nodes. The agent can create
# new _relationship_type nodes as needed,
# checking that they do not already exist.
# all _relationship_type nodes have names
# they must be unique in the system.
#
# There are a few standard _relationship_type nodes:
# instance_of, subclass_of, 
# The instance_of relationship is used to assert that
# an _entity is an instance of a class,
# i.e. that the target node must be an instance of _class
# The subclass_of relationship is used to assert that
# an _entity is a subclass of another class.
# each _relationship_type node has a _description
# property (text) that documents the appropriate use of
# the _relationship_type by the LLM.
#
# The _description includes class constraints that require that the 
# source or target must be instances of one or more classes.
#
# When a relationship (edge)
# between _entity nodes is asserted, the edge can 
# optionally have a "_context" property that is a list of 
# the names of entities which form the context for
# the relationship. "_context" is a list of _entity
# node names for which the edge is relevant. The
# meaning of "context" and "relevant" is left to the
# agent to define.
#  
# _action These nodes represent actions that the agent
# has taken, or plans to take. They are used to record
# the agent's actions and plans. The _action nodes
# have a _description property that documents the
# action or plan. Instances are also are instances of 
# a class of actions. Classes of action are predefined
# (for the moment) and must include a specific function
# call format. Actions have _time, _status, and 
# _result properties. The _time property is a datetime.
# The _status property can be "succeeded", "failed", "planned". 
# "pending", or "abandoned". The _result property
# is a string.
#
# _action nodes have _depends_on relationships to that are
# _action nodes that must be completed before
# the action can be completed. (vice versa for _depended_on_by)
# Actions _has_goal instances of _goal (and vice versa for _required_action). 
# The _goal node has a _description property that
# documents the goal. The _goal node has a _status
# property that can be "achieved", "failed", "active",
# Planning by an agent is the process of creating
# goals and actions to achieve the goals.
#
# _goal These nodes represent goals that the agent
# is currently trying to achieve, has achieved, has
# abandoned, or has failed to achieve. 
#
# This is *internal* to the agent. The agent does not 
# model the goals of other agents (including users) using the _goal node.
# rather, the agent's _goal nodes are ultimately derived from
# user goals. The agent will develop its own methods of 
# representing user goals. It may be only in the _description
# of a _goal node that the user's goal is mentioned.
#
# _kb_assertion_types
# _assert_property
# _remove_property
# _assert_relationship
# _deprecate_relationship
# _assert_entity
# _deprecate_entity
# _assert_action
# _abandon_action
# _complete_action
# _assert_goal
# _abandon_goal
# _complete_goal
#
# _kb_query_types
# _query_property
# _query_relationship
# _query_entity
#
# _action_types
# _propose_assertion
# _propose_vocabulary
# _
# --- we want to provide results to the user asynchronously.
# --- the user can ask for the results of a query when they
# --- are ready. Meanwhile, the agent can continue to work.
# --- The agent can also ask the user for more information
# --- asynchronously.
# --- The user can also ask the agent to stop working on a
# --- goal or action.
# --- The agent can also ask the user to confirm or correct
# --- information.
# --- The agent can also ask the user to provide more
# --- information.
# because actions have dependencies, the agent can recognize which
# actions are ready to be executed, and execute them.
# actions proposed as part of achieving a goal are distinguished
# from actions that result in achiving the goal. Other actions
# achieve subgoals
# when a goal is abandoned, all actions that are part of the
# plan to achieve the goal are also abandoned.
# when a goal is completed, all actions that are part of the
# plan to achieve the goal are also completed.

The operators are intended
# to be used by the agent to:
# - assert and query properties
# - assert and query relationships.
# - record events generated as the agent performs its main loop.
# - 
# The agent will only use these operators, wrapped as
# langchain tools in the agent.py module.

from gooseberry.db.db_access import DBAccess

class KBInterface
# this method asserts a property of an entity
# the method returns True if the property is asserted
# and False if it is not
# if the property is not asserted, the method will
# assert it. If the property is asserted, the method
# will do nothing.
# the property must be a string and the value can be any
# type. The property must be in the set of known_properties

    def assert_property(self, entity, property, value):
        pass

